create index idx_prodname on product(prod_name);
--1. Fetch order details along with product name and price
select o.ord_id ,o.ord_date ,o.ord_type ,p.prod_name ,p.price,p.prod_id
from orders o inner join product p
on o.prod_id = p.prod_id;

--2. Total revenue generated by each product
explain select p.prod_id,p.prod_name ,sum(p.price)
from product p inner join orders o
on o.prod_id = p.prod_id group by p.prod_id

--3. Products that have never been ordered
select p.prod_name,o.prod_id,p.prod_id from
product p left outer join orders o
on o.prod_id = p.prod_id
where o.prod_id IS NULL

--4. Products with more repeat orders than new orders

select p.prod_name, p.prod_id ,
from product p right outer join orders o 
on p.prod_id = o.prod_id
group by p.prod_id having count(o.prod_id)>1

--5. Top 3 products based on number of orders
select p.prod_id,p.prod_name,count(p.prod_id)
from product p inner join 
orders o on p.prod_id = o.prod_id
group by p.prod_id order by count(p.prod_id) desc limit (3)




select column_name,data_type from information_schema.columns where table_name ='product';

INSERT INTO product 
(prod_id, prod_name, prod_desc, price, prod_category)
VALUES
(102, 'Keyboard', 'Mechanical Keyboard', 3500.50, 'Electronics'),
(103, 'Notebook', 'A4 Size Notebook', 120.00, 'Stationery'),
(104, 'Mouse', 'Wireless Mouse', 899.99, 'Electronics');

INSERT INTO orders (ord_id, ord_date, ord_type, prod_id)
VALUES
(12, '2026-02-18', 'Online', 103)

INSERT INTO orders (ord_date, ord_type, prod_id)
VALUES
('2026-02-25', 'New', 7),
('2026-02-25', 'Repeat', 3),
('2026-02-26', 'New', 1),
('2026-02-26', 'Repeat', 103),
('2026-02-27', 'New', 104),
('2026-02-27', 'Repeat', 104);



--6. Total revenue from 'new' and 'repeat' orders separately
select o.ord_type sum(p.price)
from product p inner join 
orders o on p.prod_id = o.prod_id
group by o.ord_type having o.ord_type ='New' or o.ord_type ='Repeat'

--7. Month-wise total revenue
SELECT 
    TO_CHAR(o.ord_date, 'YYYY-MM') AS monthly,
    SUM(p.price) 
FROM product p
JOIN orders o 
    ON p.prod_id = o.prod_id
GROUP BY monthly
ORDER BY monthly;


CREATE OR REPLACE FUNCTION SUM_OF_TWO( a INT ,  b INT )
RETURNS INT
AS   $$
Begin 
return a+b;
end
$$ language plpgsql;


SELECT SUM_OF_TWO(10,30);

---- create a function that takes the product name as input and returns the price

CREATE OR REPLACE FUNCTION prod_details(prod_name1 Varchar)
returns int 
as $$
declare prod_price int;
begin 
select price into prod_price from product where prod_name = prod_name1;
return prod_price;

end
$$ language plpgsql
---- create a function that takes the product name as input and returns the table
CREATE OR REPLACE FUNCTION product_details(prod_name1 Varchar)
returns table  (p_id int ,p_name varchar)
as $$
begin 

return query select prod_id,prod_desc  from product where prod_name = prod_name1;


end
$$ language plpgsql


select * from product_details('Broom');


--create the procedure that takes product feilds as input and adds new row in the product table

create or replace procedure product_insertion(  p_name varchar, p_desc varchar, p_category varchar,p_price int  )
as $$
begin

insert into product (prod_name,prod_desc,prod_category, price) values (p_name,p_desc,p_category,p_price);

end
$$
 language plpgsql

 call product_insertion('shampoo','Dove','House hold',500);

 select * from product ;



 --write procedure that takes prod id and discounted price as input 
 -- and apply discounted price in all electronics item

 create or replace procedure apply_discount( product_id int  , discount int  )
 as $$
 begin

update product set price = price - discount
where prod_id = product_id and prod_category = 'Electronics' ;

end
$$
language plpgsql

call apply_discount(104,10)

select * from product where prod_id = 104

-- Create accounts table having id, name and balance field

create table accounts (
id int ,
name varchar,
balance NUMERIC
)
-- Create account_audit table having account_id, old_balance, new_balance, changed_on fields

create table account_audit(
account_id NUMERIC,
old_balance NUMERIC,
new_balance NUMERIC,
changed_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)

--Trigger function 
create or replace function log_trigger_function()
returns trigger
as $$
begin 
insert into account_audit (account_id,old_balance,new_balance)
values (old.id,old.balance,new.balance);
 return new;
 end;
 $$ language plpgsql;


 --trigger
 create trigger balance_update_trigger
 after update on accounts
 for each row 
 when(old.balance is distinct from new.balance)
 execute function log_trigger_function();


 --insert account
 insert into account_audit(account_id,old_balance,new_balance) values 
 (2,200,500);

 select * from account_audit 
 select * from accounts

 update accounts set balance = 10000 where id = 1